<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 6f2a633c724ec85d782aa19349987258b7b13557 Maintainer: nilgun Status: ready -->
<chapter xml:id="pdo.prepared-statements" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Hazır deyimler ve Saklı Yordamlar</title>
 <para>
  Genellikle gelişkin veritabanlarınca desteklenen, hazır deyimler diye
  bilinen bir kavram vardır. Bunlar nedir? Bunları bir takım değiştirgelerle
  özelleştirilebilen, SQL için derlenmiş şablonlar olarak düşünebilirsiniz.
  Hazır deyimlerin başlıca iki yararı vardır:
 </para>
 <itemizedlist>
  <listitem>
   <simpara>
    Sorgunun tek bir defa çözümlenmesi (veya hazırlanması) gerekir fakat aynı
    veya farklı değiştirgelerle defalarca çalıştırılabilir. Sorgu hazır
    olduğunda veritabanınca incelenir, derlenip sorgunun amacına uygun olarak
    en iyilenir. Karmaşık sorgularda aynı sorguyu farklı değiştirgelerle
    defalarca yineleyecekseniz işlemler, uygulamanızı farkedilir şekilde
    yavaşlatacak kadar uzun sürebilir. Hazır deyimleri kullanarak her
    yinelemede tekrarlanan inceleme/derleme/eniyileme döngüsünden
    kurtulabilirsiniz. Özetle, hazır deyimler daha az özkaynak kullandığından
    daha hızlı çalışır.
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    Hazır deyim değiştirgelerinin öncelenmesi gerekmez. Bu işlemi sürücüler
    sizin yerinize yapar. Uygulamanız özellikle hazır deyimleri kullanıyorsa
    hiçbir SQL zerkinin olmayacağından emin olabilirsiniz. (Ancak, sorgunun
    diğer parçaları öncelenmemiş girdiler içeriyorsa hala risk
    altındasınız demektir.)
   </simpara>
  </listitem>
 </itemizedlist>
 <para>
  Hazır deyimleri kullanmanın bir başka yararı da bunları desteklemeyen
  sürücüler için PDO'nun bu özelliği taklit etmesidir (PDO'nun taklit ettiği
  tek özellik budur). Böylece aynı veri erişim uygulamasını veritabanınızın
  yeteneklerinden bağımsız olarak kullanabilirsiniz.
 </para>
 <para>
  <example>
   <title>- Hazır deyimlerle değiştirge ismine göre veri girişi</title>
   <simpara>
    Bu örnekte <literal>isim</literal> ve <literal>deger</literal> alanlarına
    değiştirgelerin isimlerine göre bir INSERT sorgusu ile defalarca veri
    girilmektedir.
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
$deyim = $dbh->prepare(
          "INSERT INTO KUTUK (isim, deger) VALUES (:isim, :deger)");
$deyim->bindParam(':isim', $isim);
$deyim->bindParam(':değer', $değer);

// bir satıra veri girelim
$isim = 'bir';
$değer = 1;
$deyim->execute();

// farklı değerlerle bir satır daha girelim
$isim = 'iki';
$değer = 2;
$deyim->execute();
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  <example>
   <title>- Hazır deyimlerle değiştirge indisine göre veri girişi</title>
   <simpara>
    Bu örnekte <literal>isim</literal> ve <literal>deger</literal> alanlarına
    değiştirgelerin indislerine göre bir INSERT sorgusu ile defalarca veri
    girilmektedir.
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
$deyim = $dbh->prepare("INSERT INTO KUTUK (isim, değer) VALUES (?, ?)");
$deyim->bindParam(1, $isim);
$deyim->bindParam(2, $değer);

// bir satıra veri girelim
$isim = 'bir';
$değer = 1;
$deyim->execute();

// farklı değerlerle bir satır daha girelim
$isim = 'iki';
$değer = 2;
$deyim->execute();
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  <example>
   <title>- Hazır deyimle veri almak</title>
   <simpara>
    Bu örnekte bir formdan sağlanan bir anahtar değere dayanarak
    veritabanından veri alınmaktadır. Kullanıcı girdisi otomatik olarak
    öncelenmekte, dolayısıya bir SQL zerki riski ortaya çıkmamaktadır.
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
$deyim = $dbh->prepare("SELECT * FROM KUTUK where isim = ?");
if ($deyim->execute(array($_GET['isim']))) {
  while ($satır = $deyim->fetch()) {
    print_r($satır);
  }
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  <example>
   <title>- Bir saklı yordamın çıktı değiştirgesi ile kullanımı</title>
   <simpara>
    Eğer veritabanı sürücüsü değiştirge ilişkilendirmeyi destekiyorsa
    değiştirgeleri sadece girdide değil çıktıda da değiştirgelerle
    ilişkilendirebilirsiniz. Çıktı değiştirgelerinin kullanımı girdi
    değiştirgelerine göre daha karmaşıktır. Böyle bir durumda
    ilişkilendirdiğiniz değiştirge sayısını bilmeniz gerekir. Eğer dönen değer
    önerdiğinizden daha büyükse bir hata oluşur.
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
$deyim = $dbh->prepare("CALL sy_dizge_döndürür(?)");
$deyim->bindParam(1, $dönen_değer, PDO::PARAM_STR, 4000);

// saklı yordamı çağıralım
$deyim->execute();

print "dönen değer: $dönen_değer\n";
?>
]]>
   </programlisting>
  </example>
 </para>

 <para>
  <example>
   <title>- Bir saklı yordamın girdi/çıktı değiştirgesi ile kullanımı</title>
   <simpara>
    Ayrıca, değerleri tutan değiştirgeleri hem girdi hem de çıktı için
    kullanabilirsiniz. Sonraki örnekte, saklı yordama 'merhaba' dizgesi
    aktarılmakta, yordam döndüğünde 'merhaba' yerine yordamın dönüş değeri
    yerleştirilmektedir.
   </simpara>
   <programlisting role="php">
<![CDATA[
<?php
$deyim = $dbh->prepare("CALL sy_dizge_alır_dizge_döndürür(?)");
$değer = 'merhaba';
$deyim->bindParam(1, $değer, PDO::PARAM_STR|PDO::PARAM_INPUT_OUTPUT, 4000);

// saklı yordamı çağıralım
$deyim->execute();

print "dönen değer: $değer\n";
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  <example>
   <title>- Geçersiz değiştirge kullanımı</title>
   <programlisting role="php">
<![CDATA[
<?php
$deyim = $dbh->prepare("SELECT * FROM KUTUK where isim LIKE '%?%'");
$deyim->execute(array($_GET['isim']));

// değiştirge değerin yerinde kullanılmalı
$deyim = $dbh->prepare("SELECT * FROM KUTUK where isim LIKE ?");
$deyim->execute(array("%$_GET[isim]%"));
?>
]]>
   </programlisting>
  </example>
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

